<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>lib-basic-linechart-documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">lib-basic-linechart-documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>Data</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/basic-linechart/src/lib/basic-linechart.component.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Data&#39;s format for the component</p>

            </p>


        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#color">color</a>
                                </li>
                                <li>
                                        <a href="#interpolation">interpolation</a>
                                </li>
                                <li>
                                        <a href="#label">label</a>
                                </li>
                                <li>
                                        <a href="#style">style</a>
                                </li>
                                <li>
                                        <a href="#values">values</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="color"></a>
                                        <span class="name"><b>color</b><a href="#color"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>color:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Line or area color you can fill with name, hexacode or rgb code.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="interpolation"></a>
                                        <span class="name"><b>interpolation</b><a href="#interpolation"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>interpolation:     <code>&quot;linear&quot; | &quot;step&quot;</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>&quot;linear&quot; | &quot;step&quot;</code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Interpolation of line 
Recommanded : step for discrete values and linear for continuous values</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="label"></a>
                                        <span class="name"><b>label</b><a href="#label"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>label:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Data&#39;s name</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="style"></a>
                                        <span class="name"><b>style</b><a href="#style"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>style:     <code>&quot;line&quot; | &quot;area&quot; | &quot;both&quot;</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>&quot;line&quot; | &quot;area&quot; | &quot;both&quot;</code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Style of line</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="values"></a>
                                        <span class="name"><b>values</b><a href="#values"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>values:     <code>[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>[]</code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Data&#39;s values [timestamp,value][]</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, ElementRef, EventEmitter, HostListener, Input, OnInit, Output, Renderer2, SimpleChanges, ViewChild } from &#x27;@angular/core&#x27;;
import {ScaleTime, ScaleLinear} from &#x27;d3-scale&#x27;;
import {Selection} from &#x27;d3-selection&#x27;;
import * as d3 from &#x27;d3&#x27;;

/**
 * Data&#x27;s format for the component
 */
export interface Data {
  /**
   * Data&#x27;s name
   */
  label: string;

  /**
   * Data&#x27;s values [timestamp,value][]
   */
  values: [number,number][];
  /**
   * Line or area color you can fill with name, hexacode or rgb code.
   */
  color: string;
  /**
   * Style of line
   */
  style: &quot;line&quot; | &quot;area&quot; | &quot;both&quot;;
  /**
   * Interpolation of line 
   * Recommanded : step for discrete values and linear for continuous values
   */
  interpolation: &quot;linear&quot; | &quot;step&quot;;
}

@Component({
  selector: &#x27;lib-basic-linechart&#x27;,
  template: &#x60;
  &lt;div #element&gt;
  &lt;h2&gt;{{ title }}&lt;/h2&gt;
  &lt;svg #root [attr.width]&#x3D;&quot;width&quot; [attr.height]&#x3D;&quot;height&quot;&gt;&lt;/svg&gt;
  &lt;div #zone&gt;&lt;div #scroll&gt;&lt;/div&gt;&lt;/div&gt;
  &lt;/div&gt;
  &#x60;,
  styles: [
  ]
})
export class BasicLinechartComponent implements OnInit {
  /**
   * Input width of the component
   * Default value : 900
   */
  @Input() width: number &#x3D; 900;
  
  /**
   * Input height of the compenent
   * Default value : 200
   */
  @Input() height: number &#x3D; 200;
  
  /**
   * Input data array that the component display
   * Default value : []
   */
  @Input() data: Data[] &#x3D; [];

  /**
   * Input domain of the Axis Y
   * Works only for continuous values
   * Default value : [0,0]
   */
  @Input() domain: [number, number] &#x3D; [0,0];
  
  /**
   * Input speed of zoom between 0 and 1
   * Default value : 0.2
   */
  @Input() speedZoom: number &#x3D; 0.2;
  
  /**
   * ElementRef of DOM Element root
   * It&#x27;s a svg with the linechart
   */
  @ViewChild(&#x27;root&#x27;) timeline!: ElementRef;

  /**
   * ElementRef of DOM Element scroll
   * It&#x27;s a div that will be the scrollbar
   */
  @ViewChild(&#x27;scroll&#x27;) scrollbar!: ElementRef;

  /**
   * ElementRef of DOM Element zone
   * It&#x27;s a div that will be the zone of scrollbar
   */
  @ViewChild(&#x27;zone&#x27;) zoneScrollbar!: ElementRef;

  /**
   * ElementRef of DOM Element element
   * It&#x27;s a div that contains all the others Dom Element
   */
  @ViewChild(&#x27;element&#x27;) compo!: ElementRef;

  /**
   * Input range of timestamp
   * Default value : [0,0]
   */
  @Input() range: [number,number] &#x3D; [0,0];
  
  /**
   * Output rangeChange that emit range 
   */
  @Output() rangeChange &#x3D; new EventEmitter&lt;[number,number]&gt;();
  
  /**
   * Input currentTime
   * Default value : 0
   */
  @Input() currentTime: number &#x3D; 0;
  
  /**
   * Output currentTimeChange that emit currentTime
   */
  @Output() currentTimeChange &#x3D; new EventEmitter&lt;number&gt;();
  
  /**
   * Title of the component
   */
  public title:string &#x3D; &#x27;Timeline : &#x27;;
  
  /**
   * Margin of the component
   */
  private margin:{top:number,right:number,bottom:number,left:number} &#x3D; { top: 20, right: 20, bottom: 20, left: 20 }; //marge interne au svg 
  
  /**
   * dataZoom is a copy of data with the range specify
   */
  private dataZoom: Data[] &#x3D; [];
  
  /**
   * idZoom is the number of wheel notch
   */
  private idZoom: number &#x3D; 0;
  
  /**
   * It&#x27;s the smallest timestamp of data
   */
  private minTime: number &#x3D; 0;
  
  /**
   * It&#x27;s the biggest timestamp of data
   */
  private maxTime: number &#x3D; 0;
  
  /**
   * It&#x27;s the difference between the smallest and the biggest
   */
  private lengthTime: number &#x3D; 0;
  
  /**
   * Width of the svg
   */
  private svgWidth: number &#x3D; 0;
  
  /**
   * Height of the svg
   */
  private svgHeight: number &#x3D; 0;
  
  /**
   * Scale of the X axis
   */
  private scaleX: ScaleTime&lt;number,number&gt; &#x3D; d3.scaleTime();
  
  /**
   * Scale of the Y axis
   */
  private scaleY: ScaleLinear&lt;number,number&gt; &#x3D; d3.scaleLinear();

  /**
   * svg that contain the linechart and the axis
   */
  private svg: any;

  /**
   * Array of area definition
   */
  private area: d3.Area&lt;[number, number]&gt;[] &#x3D; [];

  /**
   * Array of line definition
   */
  private line: d3.Line&lt;[number, number]&gt;[] &#x3D; [];

  /**
   * Svg definition of the tooltip
   */
  private tooltip!: Selection&lt;SVGGElement,unknown,null,undefined&gt;;

  /**
   * data length before the new change
   */
  private lastDatalength:number &#x3D; 0;

  /**
   * Mode of the tooltip
   */
  private modeToolTips: &quot;normal&quot; | &quot;inverse&quot; &#x3D; &quot;normal&quot;;

  /**
   * true if the currentTimeline is selected
   */
  private currentTimeSelected:boolean &#x3D; false;

  /**
   * true if the scrollbar is selected
   */
  private scrollbarSelected:boolean &#x3D; false;

  /**
   * Last position of the mouse
   */
  private lastPos: number &#x3D; 0;

  /**
   * true if the CTRL Key of keyBoard is push 
   */
  private zoomSelected: boolean &#x3D; false;

  @HostListener(&#x27;window:keydown&#x27;, [&#x27;$event&#x27;])
  handleKeyDown(event: KeyboardEvent){
    if(event.ctrlKey&amp;&amp;!this.zoomSelected){
      this.zoomSelected &#x3D; true;
    } 
  }
  @HostListener(&#x27;window:keyup&#x27;, [&#x27;$event&#x27;])
  handleKeyUp(){
    this.zoomSelected &#x3D; false;
  }
  
  /**
   * Constructor : Init renderer
   * @param renderer 
   */
  constructor(private renderer: Renderer2) {   
  }

  /**
   * Copy data in dataZoom, and build title 
   */
  public ngOnInit(): void {
    this.dataZoom &#x3D; [...this.data];
    this.lastDatalength&#x3D;this.dataZoom.length;
    this.data.forEach((element,index) &#x3D;&gt; {
      if(index&#x3D;&#x3D;this.data.length-1) this.title &#x3D; this.title+element.label+&#x27;.&#x27;;
      else this.title &#x3D; this.title+element.label + &#x27;, &#x27;;
    })
  }

  /**
   * Initialize linechart
   */
  public ngAfterViewInit(): void {
    if (this.timeline !&#x3D; undefined) {
      let w &#x3D; this.timeline.nativeElement.width.animVal.value;
      let h &#x3D; this.timeline.nativeElement.height.animVal.value;
      this.svgWidth &#x3D; (w - this.margin.left) - this.margin.right;
      this.svgHeight &#x3D; (h - this.margin.top) - this.margin.bottom;
    }
    this.data.forEach((element,index) &#x3D;&gt; this.buildStyleData(element,index));
    this.controlSpeedZoom();
    this.buildZoom(); 
    this.buildEvent();
    this.drawToolTips();
    this.drawAxis();
    this.drawLineAndPath();
    this.drawLineCurrentTime();
    this.drawScrollbar();
  }

  /**
   * Update linechart on data, range or current time changes
   * @param {SimpleChanges} changes 
   */
  public ngOnChanges(changes: SimpleChanges): void {
    if (changes.data&amp;&amp;!changes.data.firstChange) this.updateChart();
    if ((changes.data&amp;&amp;!changes.data.firstChange&amp;&amp;this.range[0]!&#x3D;0&amp;&amp;this.range[1]!&#x3D;0)||(changes.range&amp;&amp;!changes.range.firstChange)) {
      this.idZoom&#x3D;Math.round(Math.log(this.lengthTime/(this.range[1]-this.range[0]))/Math.log(1+this.speedZoom));
      this.range&#x3D;this.controlRange(this.range[0],this.range[1]-this.range[0]);
      if(this.data.length!&#x3D;0){
        this.updateDataZoom(this.range[0],this.range[1]);
        this.updateSvg(this.range[0],this.range[1]);
      }
    }
    if (changes.currentTime&amp;&amp;!changes.currentTime.firstChange&amp;&amp;this.data.length!&#x3D;0) this.updateCurrentTime();
}

  /**
   * Add event listeners on the svg
   */
  private buildEvent(): void{ // creer une timeline avec une seul donnée
    this.svg &#x3D; d3.select(this.timeline.nativeElement)
    .append(&#x27;g&#x27;)
    .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + this.margin.left + &#x27;,&#x27; + this.margin.top + &#x27;)&#x27;);
    d3.select(this.timeline.nativeElement).on(&quot;mousemove&quot;, (event: MouseEvent) &#x3D;&gt; {
      if(this.currentTimeSelected) this.moveCurrentTime(event);
      else this.showInfo(event);
    })
    .on(&quot;mouseleave&quot;, () &#x3D;&gt; { this.currentTimeSelected &#x3D; false; this.hideInfo() })
    .on(&quot;wheel&quot;, (event: WheelEvent) &#x3D;&gt; {if(this.data.length!&#x3D;0)if(this.zoomSelected){this.activeZoom(event)}})
    .on(&quot;mouseup&quot;, () &#x3D;&gt; this.currentTimeSelected&#x3D;false)
    .on(&quot;mouseover&quot;, (event: MouseEvent) &#x3D;&gt; event.preventDefault());
  }

  /**
   * Build the style (area, line or both) and the interpolation (stpe or linear) of lines
   * @param {Data} element 
   * @param {number} index 
   */
  private buildStyleData(element:Data, index:number): void{
    if(element.style&#x3D;&#x3D;&quot;area&quot; || element.style&#x3D;&#x3D;&quot;both&quot;){
      if(element.interpolation&#x3D;&#x3D;&quot;step&quot;){
        this.area[index]&#x3D;d3.area()
        .x((d: number[]) &#x3D;&gt; this.scaleX(d[0]))
        .y0(this.svgHeight)
        .y1((d: number[]) &#x3D;&gt; this.scaleY(d[1]))
        .curve(d3.curveStepAfter);
      }else{
        this.area[index]&#x3D;d3.area()
        .x((d: number[]) &#x3D;&gt; this.scaleX(d[0]))
        .y0(this.svgHeight)
        .y1((d: number[]) &#x3D;&gt; this.scaleY(d[1]))
      }
    }
    if(element.style&#x3D;&#x3D;&quot;line&quot; || element.style&#x3D;&#x3D;&quot;both&quot;){
      if(element.interpolation&#x3D;&#x3D;&quot;step&quot;){
        this.line[index]&#x3D;d3.line()
        .x((d: number[]) &#x3D;&gt; this.scaleX(d[0]))
        .y((d: number[]) &#x3D;&gt; this.scaleY(d[1]))
        .curve(d3.curveStepAfter);
      }else{
        this.line[index]&#x3D;d3.line()
        .x((d: number[]) &#x3D;&gt; this.scaleX(d[0]))
        .y((d: number[]) &#x3D;&gt; this.scaleY(d[1]))
      }
    }
    if(!this.controlColor(element.color)){
      console.warn(&quot;Data with &quot; + element.label + &quot; label, has an unvalid color attribute (&quot; + element.color + &quot;). Replace with the default color (black).&quot;);
      element.color&#x3D;&quot;black&quot;;
    } 
  }

  /**
   * Save information for zoom.
   */
  private buildZoom(): void{
    this.minTime &#x3D; this.scale(this.data,&quot;xMin&quot;);
    this.maxTime &#x3D; this.scale(this.data,&quot;xMax&quot;);
    this.lengthTime &#x3D; this.maxTime - this.minTime;
    this.idZoom&#x3D;0;
  }

  /**
   * Draw the tooltips&#x27;s svg
   */
  private drawToolTips(): void{ //creer le tooltips
    this.tooltip &#x3D; this.svg.append(&quot;g&quot;)
        .attr(&quot;id&quot;, &quot;tooltip&quot;)
        .style(&quot;display&quot;, &quot;none&quot;);
    // Le cercle extérieur bleu clair
    this.tooltip.append(&quot;circle&quot;)
        .attr(&quot;fill&quot;, &quot;#CCE5F6&quot;)
        .attr(&quot;r&quot;, 10);
    // Le cercle intérieur bleu foncé
    this.tooltip.append(&quot;circle&quot;)
        .attr(&quot;fill&quot;, &quot;#3498db&quot;)
        .attr(&quot;stroke&quot;, &quot;#fff&quot;)
        .attr(&quot;stroke-width&quot;, &quot;1.5px&quot;)
        .attr(&quot;r&quot;, 4);
    // Le tooltip en lui-même avec sa pointe vers le bas
    // Il faut le dimensionner en fonction du contenu
    if (this.modeToolTips &#x3D;&#x3D; &quot;normal&quot;) {
      this.tooltip.append(&quot;polyline&quot;)
        .attr(&quot;points&quot;, &quot;0,0 0,40 75,40  80,45  85,40  160,40  160,0 0,0&quot;)
        .style(&quot;fill&quot;, &quot;#fafafa&quot;)
        .style(&quot;stroke&quot;,&quot;#3498db&quot;)
        .style(&quot;opacity&quot;,&quot;0.9&quot;)
        .style(&quot;stroke-width&quot;,&quot;1&quot;)
        .attr(&quot;transform&quot;, &quot;translate(-80,-50)&quot;);
      this.dataZoom.forEach((element) &#x3D;&gt; {
        // Cet élément contiendra tout notre texte
        let text &#x3D; this.tooltip.append(&quot;text&quot;)
          .style(&quot;font-size&quot;, &quot;13px&quot;)
          .style(&quot;font-family&quot;, &quot;Segoe UI&quot;)
          .style(&quot;color&quot;, element.color)
          .style(&quot;fill&quot;, element.color)
          .attr(&quot;transform&quot;, &quot;translate(-80,-42)&quot;);
        // Element pour la date avec positionnement spécifique
        text.append(&quot;tspan&quot;)
          .attr(&quot;dx&quot;, &quot;7&quot;)
          .attr(&quot;dy&quot;, &quot;5&quot;)
          .attr(&quot;id&quot;, &quot;tooltip-date1&quot;);
        text.append(&quot;tspan&quot;)
          .attr(&quot;dx&quot;, &quot;-90&quot;)
          .attr(&quot;dy&quot;, &quot;15&quot;)
          .attr(&quot;id&quot;, &quot;tooltip-date2&quot;);
      });
    }else {
      this.tooltip.append(&quot;polyline&quot;)
        .attr(&quot;points&quot;, &quot;0,95 , 0,55 , 75,55 , 80,50 , 85,55 , 160,55 , 160,95 0,95&quot;)
        .style(&quot;fill&quot;, &quot;#fafafa&quot;)
        .style(&quot;stroke&quot;,&quot;#3498db&quot;)
        .style(&quot;opacity&quot;,&quot;0.9&quot;)
        .style(&quot;stroke-width&quot;,&quot;1&quot;)
        .attr(&quot;transform&quot;, &quot;translate(-80,-50)&quot;);
      this.dataZoom.forEach((element) &#x3D;&gt; {
        // Cet élément contiendra tout notre texte
        let text &#x3D; this.tooltip.append(&quot;text&quot;)
          .style(&quot;font-size&quot;, &quot;13px&quot;)
          .style(&quot;font-family&quot;, &quot;Segoe UI&quot;)
          .style(&quot;color&quot;, element.color)
          .style(&quot;fill&quot;, element.color)
          .attr(&quot;transform&quot;, &quot;translate(-80,-30)&quot;);
        // Element pour la date avec positionnement spécifique
        text.append(&quot;tspan&quot;)
          .attr(&quot;dx&quot;, &quot;7&quot;)
          .attr(&quot;dy&quot;, 50 )
          .attr(&quot;id&quot;, &quot;tooltip-date1&quot;);
        text.append(&quot;tspan&quot;)
          .attr(&quot;dx&quot;, &quot;-80&quot;)
          .attr(&quot;dy&quot;, &quot;20&quot;)
          .attr(&quot;id&quot;, &quot;tooltip-date2&quot;);
      });
    }
  }

  /**
   * Draw horizontal and vertical axis and scale
   */
  private drawAxis(): void{
    this.scaleX.range([0, this.svgWidth]);
    this.scaleX.domain([this.minTime,this.maxTime]);
    this.scaleY &#x3D; d3.scaleLinear();
    this.scaleY.range([this.svgHeight, 0]);
    this.scaleY.domain(this.controlDomain());
    // Configure the X Axis
    this.svg.append(&#x27;g&#x27;)
      .attr(&#x27;transform&#x27;, &#x27;translate(0,&#x27; + this.svgHeight + &#x27;)&#x27;)
      .attr(&#x27;class&#x27;, &#x27;xAxis&#x27;)
      .call(d3.axisBottom(this.scaleX));
    // Configure the Y Axis
    if(this.discreteValue(this.data)){
      this.svg.append(&#x27;g&#x27;)
      .attr(&#x27;class&#x27;, &#x27;yAxis&#x27;)
      .call(d3.axisLeft(this.scaleY).ticks(this.scale(this.data,&quot;yMax&quot;)));
    }else{
      this.svg.append(&#x27;g&#x27;)
      .attr(&#x27;class&#x27;, &#x27;yAxis&#x27;)
      .call(d3.axisLeft(this.scaleY));
    }
  }

  /**
   * Draw lines on the line chart
   */
  private drawLineAndPath(): void{
    this.dataZoom.forEach(
      (element,index) &#x3D;&gt; {
        if(element.style&#x3D;&#x3D;&quot;area&quot; || element.style&#x3D;&#x3D;&quot;both&quot;){
          this.svg.append(&#x27;path&#x27;)
          .datum(this.dataZoom[index].values)
          .attr(&#x27;class&#x27;, &#x27;area&#x27;+index)
          .attr(&#x27;d&#x27;, this.area[index])
          .attr(&quot;stroke-width&quot;, 0.1)
          .attr(&#x27;opacity&#x27;, 0.3)
          .style(&#x27;fill&#x27;, element.color)
          .style(&#x27;stroke&#x27;, element.color)
          .style(&#x27;stroke-width&#x27;, &#x27;2px&#x27;)
        }
        if(element.style&#x3D;&#x3D;&quot;line&quot; || element.style&#x3D;&#x3D;&quot;both&quot;){
          this.svg.append(&#x27;path&#x27;)
          .datum(element.values)
          .attr(&#x27;class&#x27;, &#x27;line&#x27;+index)
          .attr(&#x27;d&#x27;, this.line[index])
          .style(&#x27;fill&#x27;, &#x27;none&#x27;)
          .style(&#x27;stroke&#x27;, element.color)
          .style(&#x27;stroke-width&#x27;, &#x27;2px&#x27;)
        }
      }
    )
  }

  /**
   * Draw the vertical line which represents the current time
   */
  private drawLineCurrentTime(): void{
    if(this.data.length!&#x3D;0){
      if(this.currentTime&#x3D;&#x3D;0){
        this.currentTime &#x3D; this.scale(this.data,&quot;xMin&quot;);
      }
      let x:number&#x3D;0;
      this.svg.append(&#x27;path&#x27;)
        .datum([[this.currentTime,this.controlDomain()[0]],[this.currentTime,this.svgHeight]])
        .attr(&#x27;class&#x27;, &#x27;currentTimeLine&#x27;)
        .attr(&#x27;d&#x27;, d3.line()
          .x((d: number[]) &#x3D;&gt; x&#x3D;this.scaleX(d[0]))
          .y((d: number[]) &#x3D;&gt; this.scaleY(d[1])))
        .style(&#x27;fill&#x27;, &#x27;none&#x27;)
        .style(&#x27;stroke&#x27;, &#x27;red&#x27;)
        .style(&#x27;stroke-width&#x27;, &#x27;3px&#x27;);
      this.svg.append(&#x27;circle&#x27;)
        .attr(&#x27;class&#x27;, &#x27;currentTimeSelector&#x27;)
        .attr(&#x27;cx&#x27;, x)
        .attr(&#x27;cy&#x27;, -13)
        .attr(&#x27;r&#x27;, 7)
        .attr(&#x27;fill&#x27;, &#x27;red&#x27;)
        .on(&quot;mousedown&quot;, () &#x3D;&gt; {
          this.currentTimeSelected&#x3D;true;
          this.hideInfo();
        })
    }
  }

  /**
   * Draw the scrollbar and event listener on it  
   */
  private drawScrollbar(): void{
    this.zoneScrollbar.nativeElement.style.width &#x3D; this.svgWidth+&quot;px&quot;;
    this.zoneScrollbar.nativeElement.style.marginLeft &#x3D; this.margin.left+ &quot;px&quot;;
    this.zoneScrollbar.nativeElement.style.height &#x3D; &quot;20px&quot;;
    this.zoneScrollbar.nativeElement.style.backgroundColor &#x3D; &quot;lightgrey&quot;;
    this.zoneScrollbar.nativeElement.style.borderRadius &#x3D; &quot;10px&quot;;
    this.scrollbar.nativeElement.style.width &#x3D; this.svgWidth+&quot;px&quot;;
    this.scrollbar.nativeElement.style.height &#x3D; &quot;20px&quot;;
    this.scrollbar.nativeElement.style.backgroundColor &#x3D; &quot;grey&quot;;
    this.scrollbar.nativeElement.style.borderRadius &#x3D; &quot;10px&quot;;
    this.compo.nativeElement.style.width &#x3D; this.svgWidth+this.margin.left+&quot;px&quot;;
    this.compo.nativeElement.style.padding &#x3D; &quot;10px 10px 10px 10px&quot;;
    this.renderer.listen(this.scrollbar.nativeElement, &#x27;mousedown&#x27;, (event:MouseEvent) &#x3D;&gt; this.activeScrollbar(event));
    this.renderer.listen(this.compo.nativeElement, &#x27;mouseleave&#x27;, () &#x3D;&gt; this.desactiveScrollbar());
    this.renderer.listen(this.compo.nativeElement, &#x27;mouseup&#x27;, () &#x3D;&gt; this.desactiveScrollbar());
    this.renderer.listen(this.compo.nativeElement,&#x27;mousemove&#x27;, (event:MouseEvent) &#x3D;&gt; this.updateRange(event));
  }

  /**
   * Update all the line chart (horizontal and vertical axis and scale, data, lines and range) on data changes. 
   */
  private updateChart(): void{
    this.dataZoom &#x3D; [...this.data];
    this.data.forEach(
      (element,index) &#x3D;&gt; {
        this.buildStyleData(element,index);
        if(element.style&#x3D;&#x3D;&quot;area&quot;) this.svg.selectAll(&#x27;.line&#x27;+index).remove();
        if(element.style&#x3D;&#x3D;&quot;line&quot;) this.svg.selectAll(&#x27;.area&#x27;+index).remove();
        this.title &#x3D; &#x27;Timeline : &#x27;;
        if(index&#x3D;&#x3D;this.data.length-1) this.title &#x3D; this.title+element.label+&#x27;.&#x27;;
        else this.title &#x3D; this.title+element.label + &#x27;, &#x27;;
    })
    this.buildZoom();
    this.scaleX.domain([this.minTime,this.maxTime]);
    this.scaleY.range([this.svgHeight, 0]);
    this.controlDomain();
    this.scaleY.domain(this.controlDomain());
    if(this.discreteValue(this.data)){
      this.svg.selectAll(&#x27;.yAxis&#x27;)
      .call(d3.axisLeft(this.scaleY).ticks(this.scale(this.data,&quot;yMax&quot;)));
    }else{
      this.svg.selectAll(&#x27;.yAxis&#x27;)
      .call(d3.axisLeft(this.scaleY));
    }
    this.svg.selectAll(&#x27;.xAxis&#x27;).call(d3.axisBottom(this.scaleX));
    this.svg.selectAll(&#x27;.currentTimeLine&#x27;).remove();
    this.svg.selectAll(&#x27;.currentTimeSelector&#x27;).remove();
    this.updateLine();
    this.drawLineCurrentTime();
    this.updateScrollbar(this.minTime,this.maxTime);
    this.updateToolTips();
    for(let index&#x3D;this.dataZoom.length; index&lt;this.lastDatalength; index++){
      this.svg.selectAll(&#x27;.line&#x27;+index).remove();
      this.svg.selectAll(&#x27;.area&#x27;+index).remove();
    }
    this.lastDatalength&#x3D;this.dataZoom.length;
  }

  /**
   * Update horizontal axis, current time line, lines and scrollbar
   * @param {number} min of the new range
   * @param {number} max of the new range
   */
  private updateSvg(min: number, max: number){
    this.scaleX.domain([min,max]);
    this.svg.selectAll(&#x27;.xAxis&#x27;).call(d3.axisBottom(this.scaleX));
    this.updateLine();
    this.updateCurrentTime();
    this.updateScrollbar(min,max);
  }

  /**
   * Update the display of lines
   */
  private updateLine(): void{
    let lineUpdate;
    let areaUpdate;
    this.dataZoom.forEach((element,index) &#x3D;&gt; {
      if(element.style&#x3D;&#x3D;&quot;area&quot; || element.style&#x3D;&#x3D;&quot;both&quot;){
        areaUpdate&#x3D; this.svg.selectAll(&#x27;.area&#x27;+index).data([this.dataZoom[index].values]);
        areaUpdate
        .enter()
        .append(&quot;path&quot;)
        .attr(&#x27;class&#x27;, &#x27;area&#x27;+index)
        .merge(areaUpdate)
        .attr(&#x27;d&#x27;, this.area[index])
        .attr(&quot;stroke-width&quot;, 0.1)
        .attr(&#x27;opacity&#x27;, 0.3)
        .style(&#x27;fill&#x27;, element.color)
        .style(&#x27;stroke&#x27;, element.color)
        .style(&#x27;stroke-width&#x27;, &#x27;2px&#x27;);
      }
      if(element.style&#x3D;&#x3D;&quot;line&quot; || element.style&#x3D;&#x3D;&quot;both&quot;){
        lineUpdate&#x3D; this.svg.selectAll(&#x27;.line&#x27;+index).data([this.dataZoom[index].values]);
        lineUpdate
        .enter()
        .append(&quot;path&quot;)
        .attr(&#x27;class&#x27;, &#x27;line&#x27;+index)
        .merge(lineUpdate)
        .attr(&#x27;d&#x27;, this.line[index])
        .style(&#x27;fill&#x27;, &#x27;none&#x27;)
        .style(&#x27;stroke&#x27;, element.color)
        .style(&#x27;stroke-width&#x27;, &#x27;2px&#x27;)
      }
    });
  }

  /**
   * Update the position of the current time line
   */
  private updateCurrentTime(): void{
    let lineUpdate &#x3D; this.svg.selectAll(&#x27;.currentTimeLine&#x27;).datum([[this.currentTime,this.controlDomain()[0]],[this.currentTime,this.svgHeight]]);
    let x:number&#x3D;0;
    lineUpdate.enter()
    .append(&quot;path&quot;)
    .attr(&#x27;class&#x27;, &#x27;currentTimeLine&#x27;)
    .merge(lineUpdate)
    .attr(&#x27;d&#x27;, d3.line()
      .x((d: number[]) &#x3D;&gt; x&#x3D;this.scaleX(d[0]))
      .y((d: number[]) &#x3D;&gt; this.scaleY(d[1])))
    .style(&#x27;fill&#x27;, &#x27;none&#x27;)
    .style(&#x27;stroke&#x27;, &#x27;red&#x27;)
    .style(&#x27;stroke-width&#x27;, &#x27;3px&#x27;);
    if(this.currentTime&gt;&#x3D;this.scale(this.dataZoom,&quot;xMin&quot;)&amp;&amp;this.currentTime&lt;&#x3D;this.scale(this.dataZoom,&quot;xMax&quot;)){
      this.svg.selectAll(&#x27;.currentTimeLine&#x27;).attr(&#x27;display&#x27;,&#x27;block&#x27;);
      this.svg.selectAll(&#x27;.currentTimeSelector&#x27;).attr(&#x27;display&#x27;,&#x27;block&#x27;);
    }else{
      this.svg.selectAll(&#x27;.currentTimeLine&#x27;).attr(&#x27;display&#x27;,&#x27;none&#x27;);
      this.svg.selectAll(&#x27;.currentTimeSelector&#x27;).attr(&#x27;display&#x27;,&#x27;none&#x27;);
    }
    this.svg.selectAll(&#x27;.currentTimeSelector&#x27;).attr(&#x27;cx&#x27;,x);
  }

  /**
   * Update the position of the scrollbar
   * @param {number} min of the new range
   * @param {number} max of the new range
   */
  private updateScrollbar(min:number, max:number): void{
    this.scrollbar.nativeElement.style.marginLeft&#x3D; this.svgWidth*(min-this.minTime)/(this.lengthTime) + &quot;px&quot;;
    this.scrollbar.nativeElement.style.width&#x3D; this.svgWidth*(max-min)/(this.lengthTime) + &quot;px&quot;;
  }

  /**
   * Change the range, control it, update datas, update the linechart and then emit the new range.
   * @param {MouseEvent} event 
   */
  private updateRange(event: MouseEvent): void{
    if(this.scrollbarSelected){
      event.preventDefault();
      let lengthLocalTime &#x3D; this.range[1]-this.range[0];
      let lastMinLocalTime &#x3D; this.scale(this.dataZoom,&quot;xMin&quot;);
      let pos &#x3D; event.clientX-this.margin.left;
      if(this.lastPos&#x3D;&#x3D;0){
        this.lastPos&#x3D; pos;
      }
      let minLocalTime &#x3D; (pos-this.lastPos)*this.lengthTime/this.svgWidth + lastMinLocalTime;
      this.range &#x3D; this.controlRange(minLocalTime,lengthLocalTime);
      this.updateDataZoom(this.range[0],this.range[1]);
      this.updateSvg(this.range[0],this.range[1]);
      this.rangeChange.emit(this.range);
      this.lastPos&#x3D;pos;
    }
  }

  /**
   * Change this.dataZoom at range changes
   * @param {number} min of the new range
   * @param {number} max of the new range 
   */
  private updateDataZoom(min:number,max:number): void{
    this.data.forEach((element,index) &#x3D;&gt; {
      this.dataZoom[index]&#x3D;{
        label: element.label,
        values: element.values.filter((element: number[]) &#x3D;&gt; min &lt;&#x3D; element[0] &amp;&amp; element[0] &lt;&#x3D;  max),
        color: element.color,
        style: element.style,
        interpolation: element.interpolation
    }}) 
    let time: number[];
    this.data.forEach((element,index) &#x3D;&gt; {
      time&#x3D;[];
      element.values.forEach((element &#x3D;&gt; time.push(element[0])));
      let i &#x3D; d3.bisectLeft(time, min)-1;
      if(i&gt;&#x3D;0&amp;&amp;i&lt;this.data[index].values.length){
        this.dataZoom[index].values.unshift([min,(this.data[index].values[i][1])]);
      }
      this.dataZoom[index].values.push([max,this.dataZoom[index].values[this.dataZoom[index].values.length-1][1]]);
    })
  }

  /**
   * Remove and build a new tooltips
   */
  private updateToolTips(): void{
    this.tooltip.remove();
    this.drawToolTips();
  }

  /**
   * Active movement of scrollbar on mousedown on it
   * @param {MouseEvent} event 
   */ 
  private activeScrollbar(event: MouseEvent): void{
    if(this.idZoom!&#x3D;0){
      this.scrollbarSelected&#x3D;true;
      this.lastPos&#x3D;event.clientX-this.margin.left;
    }
  }

  /**
   * Desactive movement of scrollbar on mouseup or mouseleave on it
   */
  private desactiveScrollbar(): void{
    this.scrollbarSelected&#x3D;false;
    this.lastPos&#x3D;0;
  }

  /**
   * Show the tooltips on the movement of the mouse
   * @param {MouseEvent} event 
   */
  private showInfo(event: MouseEvent): void{
    if (this.dataZoom[0] !&#x3D; undefined &amp;&amp; this.dataZoom.length &lt;2) {
      var d: number&#x3D;0;
      var t: number&#x3D;0;
      let time: number[] &#x3D; [];
      this.dataZoom[0].values.forEach((element) &#x3D;&gt; time.push(element[0]));
      let x0 &#x3D; this.scaleX.invert(event.clientX - this.margin.left).getTime();
      let x &#x3D; d3.bisectRight(time, x0);
      if(x&gt;this.dataZoom[0].values.length-1)x&#x3D;this.dataZoom[0].values.length-1;
      else if (x &lt; 0) x &#x3D; 0;
        d  &#x3D; this.dataZoom[0].values[x][1];
        t &#x3D; this.dataZoom[0].values[x][0];
      let date &#x3D; new Date(t).toLocaleDateString(&quot;fr&quot;, { year: &#x27;numeric&#x27;, month: &#x27;long&#x27;, day: &#x27;numeric&#x27;, hour: &#x27;numeric&#x27;, minute: &#x27;numeric&#x27;, second: &#x27;numeric&#x27; });
      d3.selectAll(&#x27;#tooltip-date1&#x27;)
        .text(date);
      d3.selectAll(&#x27;#tooltip-date2&#x27;)
        .text(this.roundDecimal(d, 2));
      this.tooltip.style(&quot;display&quot;,&quot;block&quot;);
      this.tooltip.style(&quot;opacity&quot;, 100);
      this.tooltip.attr(&quot;transform&quot;, &quot;translate(&quot; + this.scaleX(t) + &quot;,&quot; + this.scaleY(d) + &quot;)&quot;);
      if (this.scaleY(d) &lt;&#x3D; 40 * this.dataZoom.length) {
        if (this.modeToolTips !&#x3D; &quot;inverse&quot;) {
          this.modeToolTips &#x3D; &quot;inverse&quot;;
          this.updateToolTips();
        }
      } else {
        if (this.modeToolTips !&#x3D; &quot;normal&quot;) {
          this.modeToolTips &#x3D; &quot;normal&quot;;
          this.updateToolTips();
        }
      }
    }
  }

  /**
   * Hide the tooltips when the mouse leave the svg 
   */   
  private hideInfo(): void{
    this.tooltip.style(&quot;display&quot;, &quot;none&quot;);
  }

  /**
   * Update the range (reduce or increase) of the linechart on scroll 
   * @param {WheelEvent} event 
   */
  private activeZoom(event: WheelEvent): void{
    event.preventDefault();
    let lastLengthLocalTime &#x3D; this.lengthTime / Math.pow(1+this.speedZoom,this.idZoom);
    let lastMinLocalTime &#x3D; this.scale(this.dataZoom,&quot;xMin&quot;);
    if((event.deltaY&gt;0&amp;&amp;this.idZoom&gt;0)||event.deltaY&lt;0){
      if(event.deltaY&gt;0&amp;&amp;this.idZoom&gt;0){
        this.idZoom--;
      }else if(event.deltaY&lt;0){
        this.idZoom++; 
      }
      let pos &#x3D; this.scaleX.invert(event.clientX-this.margin.left).getTime();
      let lengthLocalTime &#x3D; this.lengthTime / Math.pow(1+this.speedZoom,this.idZoom);
      if(lengthLocalTime&gt;200){
        let minLocalTime &#x3D; (lastMinLocalTime-pos)*(lengthLocalTime/lastLengthLocalTime) + pos;
        this.range &#x3D; this.controlRange(minLocalTime,lengthLocalTime);
        this.updateDataZoom(this.range[0],this.range[1]);
        this.updateSvg(this.range[0],this.range[1]);
        this.rangeChange.emit(this.range);
      }else{
        this.idZoom--;
      }
    }
  }

  /**
   * Update the value of current time on the movement of the mouse
   * @param {MouseEvent} event 
   */
  private moveCurrentTime(event: MouseEvent): void{
    event.preventDefault();
    let pos &#x3D; this.scaleX.invert(event.clientX-this.margin.left).getTime();
    if(pos&lt;this.scale(this.dataZoom,&quot;xMin&quot;)){
      this.currentTime&#x3D;this.scale(this.dataZoom,&quot;xMin&quot;);
    }else if(pos&gt;this.scale(this.dataZoom,&quot;xMax&quot;)){
      this.currentTime&#x3D;this.scale(this.dataZoom,&quot;xMax&quot;);
    }else{
      this.currentTime&#x3D;pos;
    }
    this.updateCurrentTime();
    this.currentTimeChange.emit(this.currentTime);
  }

  /**
   * Control the range based on data&#x27;s timestamp and the new range
   * @param {number} min of the new range
   * @param {number} length of the new range
   * @returns a adjusted range based on data&#x27;s timestamp
   */
  private controlRange(min:number, length:number) : [number,number]{
    if(this.minTime&gt;min) min&#x3D;this.minTime;
    let max &#x3D; min + length;
    if(this.maxTime&lt;max){
      max&#x3D;this.maxTime;
      min&#x3D;max - length;
    }
    if(this.minTime&gt;min) min&#x3D;this.minTime;
    return [min,max];
  }

  /**
   * Control the domain based on data&#x27;s value type and the input domain
   * @returns a new domain auto-scaled if the input domain is equal to [0,0] or the data&#x27;s value are positive integers, else return the input domain 
   */
  private controlDomain():[number,number]{
    if((this.domain[0]&#x3D;&#x3D;0&amp;&amp;this.domain[1]&#x3D;&#x3D;0)||this.discreteValue(this.data)){
      return [this.scale(this.data,&quot;yMin&quot;),this.scale(this.data,&quot;yMax&quot;)];
    }else{
      return this.domain;
    }
  }

  /**
   * Control the color based on css-colors-name and hex-color-code
   * @param {string} color 
   * @returns false if the param color isn&#x27;t a css-colors-name or a valid hex-color-code
   */
  private controlColor(color: string):boolean{
    let s &#x3D; new Option().style;
    s.color &#x3D; color;
    return s.color!&#x3D;&quot;&quot;;
  }
  
  /**
   * Control the speedZoom if it isn&#x27;t between 0 and 1.
   */
  private controlSpeedZoom(): void{
    if(this.speedZoom&lt;&#x3D;0){
      this.speedZoom&#x3D;0.1;
    }else if(this.speedZoom&gt;1){
      this.speedZoom&#x3D;1;
    }
  }

  /** 
   * Determine the minimum or maximum of the horizontal or vertical axis in data
   * @param {Data[]} data Array of Data
   * @param {&quot;xMin&quot; | &quot;xMax&quot; | &quot;yMin&quot; | &quot;yMax&quot;} s precise wihch scale we want
   * @returns the value that matches with the parameter s in data
   */
  private scale(data: Data[], s: &quot;xMin&quot; | &quot;xMax&quot; | &quot;yMin&quot; | &quot;yMax&quot;): number {
    let res: number &#x3D; 0;
    data.forEach(
      (elements,index) &#x3D;&gt; elements.values.forEach
      ((element,i) &#x3D;&gt; {
        if((s&#x3D;&#x3D;&quot;yMin&quot;&amp;&amp;((i&#x3D;&#x3D;0&amp;&amp;index&#x3D;&#x3D;0)||element[1]&lt;res))||(s&#x3D;&#x3D;&quot;yMax&quot;&amp;&amp;((i&#x3D;&#x3D;0&amp;&amp;index&#x3D;&#x3D;0)||element[1]&gt;res))) res&#x3D;element[1];
        else if((s&#x3D;&#x3D;&quot;xMin&quot;&amp;&amp;((i&#x3D;&#x3D;0&amp;&amp;index&#x3D;&#x3D;0)||element[0]&lt;res))||(s&#x3D;&#x3D;&quot;xMax&quot;&amp;&amp;((i&#x3D;&#x3D;0&amp;&amp;index&#x3D;&#x3D;0)||element[0]&gt;res))) res&#x3D;element[0];
      })
    )
    return res;
  }

  /** 
  *Check type of data (positive integer or float)
  *@param {Data[]} data Array of Data
  *@returns false if there is at least one value in data that&#x27;s not a positive integer
  */
  private discreteValue(data: Data[]): boolean{
    for(let i:number&#x3D;0;i&lt;data.length;i++){
      for(let j:number&#x3D;0;j&lt;data[i].values.length;j++){
        if(data[i].values[j][1]!&#x3D;Math.round(data[i].values[j][1])) return false;
      }
    }
    return true;
  }

  /**
   * Round a number with a precision
   * @param {number} num 
   * @param {number} precision 
   * @returns a num with a number of decimal (precision)
   */
  private roundDecimal(num : number, precision:number): number{
    let tmp: number &#x3D; Math.pow(10, precision);
    return Math.round( num*tmp )/tmp;
  }
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'Data.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
